package mocks

import (
	"context"
	"time"

	"github.com/chris/delayed-wallet-transactions/pkg/models"
	"github.com/stretchr/testify/mock"
)

// ApiStore is an autogenerated mock type for the ApiStore type
type ApiStore struct {
	mock.Mock
}

// CreateTransaction provides a mock function with given fields: ctx, tx
func (_m *ApiStore) CreateTransaction(ctx context.Context, tx *models.Transaction) (*models.Transaction, error) {
	ret := _m.Called(ctx, tx)

	var r0 *models.Transaction
	if rf, ok := ret.Get(0).(func(context.Context, *models.Transaction) *models.Transaction); ok {
		r0 = rf(ctx, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Transaction) error); ok {
		r1 = rf(ctx, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransaction provides a mock function with given fields: ctx, id
func (_m *ApiStore) GetTransaction(ctx context.Context, id string) (*models.Transaction, error) {
	ret := _m.Called(ctx, id)

	var r0 *models.Transaction
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Transaction); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTransactionsByUserID provides a mock function with given fields: ctx, userID
func (_m *ApiStore) ListTransactionsByUserID(ctx context.Context, userID string) ([]models.Transaction, error) {
	ret := _m.Called(ctx, userID)

	var r0 []models.Transaction
	if rf, ok := ret.Get(0).(func(context.Context, string) []models.Transaction); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelTransaction provides a mock function with given fields: ctx, id
func (_m *ApiStore) CancelTransaction(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateWallet provides a mock function with given fields: ctx, wallet
func (_m *ApiStore) CreateWallet(ctx context.Context, wallet *models.Wallet) (*models.Wallet, error) {
	ret := _m.Called(ctx, wallet)

	var r0 *models.Wallet
	if rf, ok := ret.Get(0).(func(context.Context, *models.Wallet) *models.Wallet); ok {
		r0 = rf(ctx, wallet)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Wallet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Wallet) error); ok {
		r1 = rf(ctx, wallet)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWallet provides a mock function with given fields: ctx, userID
func (_m *ApiStore) GetWallet(ctx context.Context, userID string) (*models.Wallet, error) {
	ret := _m.Called(ctx, userID)

	var r0 *models.Wallet
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Wallet); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Wallet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWallets provides a mock function with given fields: ctx
func (_m *ApiStore) ListWallets(ctx context.Context) ([]models.Wallet, error) {
	ret := _m.Called(ctx)

	var r0 []models.Wallet
	if rf, ok := ret.Get(0).(func(context.Context) []models.Wallet); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Wallet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWallet provides a mock function with given fields: ctx, userID
func (_m *ApiStore) DeleteWallet(ctx context.Context, userID string) error {
	ret := _m.Called(ctx, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetStuckTransactions provides a mock function with given fields: ctx, olderThan
func (_m *ApiStore) GetStuckTransactions(ctx context.Context, olderThan time.Duration) ([]models.Transaction, error) {
	ret := _m.Called(ctx, olderThan)

	var r0 []models.Transaction
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration) []models.Transaction); ok {
		r0 = rf(ctx, olderThan)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = rf(ctx, olderThan)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLedgerEntries provides a mock function with given fields: ctx, limit
func (_m *ApiStore) ListLedgerEntries(ctx context.Context, limit int32) ([]models.LedgerEntry, error) {
	ret := _m.Called(ctx, limit)

	var r0 []models.LedgerEntry
	if rf, ok := ret.Get(0).(func(context.Context, int32) []models.LedgerEntry); ok {
		r0 = rf(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.LedgerEntry)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int32) error); ok {
		r1 = rf(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
